/*
*	Copyright (C) 2013-2014, by loafofpiecrust
*	Created: 2013-03-16 by Taylor Snead
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
*
******************************************************************************/

#include <lfant/Properties.h>

// Internal
#include <lfant/Console.h>
#include <lfant/FileSystem.h>
#include <lfant/Range.h>
#include <lfant/util/String.h>
#include <lfant/Entity.h>
#include <lfant/Scene.h>
#include <lfant/Game.h>
#include "ScriptSystem.h"

// External

namespace lfant {

using namespace std;
using namespace boost::algorithm;

Properties::Properties()
{
}

Properties::Properties(string path)
{
	LoadFile(path);
}

Properties::Properties(Properties* parent, string type, string name) :
	type(type),
	name(name),
	parent(parent)
{
	parent->AddChild(this);
}

Properties::~Properties()
{
}


Properties::Iterator Properties::begin()
{
	return Iterator(this, 0);
}

Properties::Iterator Properties::end()
{
	return Iterator(this, children.size());
}

void Properties::Get(string name, Entity*& ref, Scene* scene)
{
	int id = 0;
	string entname = "";
	Get(name, id);
	if(id == 0)
	{
		Get(name, entname);
		if(entname != "")
		{
			/// @todo implement this
			ref = scene->GetRoot()->GetChild(entname, true);
		}
	}
	else
	{
	//	ref = game->scene->GetRoot()->GetChildbyId(id);
	}
}

void Properties::Set(string name, Entity* const& value)
{
	Set(name, value->GetId());
}

void Properties::LoadFile(string path)
{
	ifstream stream(path);
	LoadStream(stream);
}

bool IsWhitespace(char c)
{
	return c == ' ' || c == '\t';
}

bool IsOperator(char c)
{
	return c == '=' || c == ':';
}

void SkipWhitespace(istream& stream, char& c)
{
	while(IsWhitespace(c))
	{
		c = stream.get();
	}
//	return c;
}

string ReadUntil(istream& stream, char& curr, string toks, bool lined)
{
	string value = "";
//	char curr = stream.get();
//	curr = stream.get();
	while(stream.good())
	{
		for(auto& t : toks)
		{
			if(curr == t) return value;
		}

		if(lined && curr == '\n')
		{
			curr = stream.get();
			SkipWhitespace(stream, curr);
		}

		value.push_back(curr);
		curr = stream.get();
	}
	return value;
}

void Properties::LoadStream(istream& stream)
{
	char curr = '\0';
	Properties* obj = this;

	string token = ""; // current token
	string stype = "";
	string sname = "";
	string value = "";
	while(stream.good())
	{
		curr = stream.get();
		if(curr == '/')
		{
			curr = stream.get();
			if(curr == '/')
			{
				while(curr != '\n')
				{
					curr = stream.get();
				}
			}
			else if(curr == '*')
			{
				while(stream.good())
				{
					curr = stream.get();
					if(curr == '*')
					{
						curr = stream.get();
						if(curr == '/')
						{
							curr = stream.get();
							break;
						}
					}
				}
			}
			else
			{
				stream.unget();
			}
		}
		if(IsWhitespace(curr) || curr == '\n' || IsOperator(curr))
		{
			// process token
			if(!token.empty())
			{
				if(token == "{")
				{
					to_lower(stype);
					erase_all(stype, " ");
					erase_all(sname, " ");
					obj = new Properties(obj, stype, sname);
					std::cout << GetIndent()+"new structure named '"+stype+" "+sname+"'\n";
					stype.clear();
					sname.clear();
				}
				else if(token == "}")
				{
					if(obj->parent) obj = obj->parent;
				}
				else if(stype.empty())
				{
					stype = token;
				}
				else if(sname.empty())
				{
					sname = token;
				}

				// clear token
				token.clear();

			}
			if(IsOperator(curr))
			{
			//	oper = curr;
				value.clear();

				bool lined = false;
				curr = stream.get();
				while(stream.good())
				{
					if(curr == '{')
						lined = true;
					else if(curr == '}')
						lined = false;

					if(!lined && (curr == ';' || curr == '\n'))
					{
						break;
					}

					value.push_back(curr);
					curr = stream.get();
				}
				value = TrimSpace(value, false);
				if(!value.empty()) obj->Set(stype, value);

				stype.clear();
				value.clear();
				sname.clear();
			}
		}
		else
		{
			token.push_back(curr);
		}
	}
	return;
}

void Properties::SaveStream(ostream &stream)
{
//	stream << "// Scene file generated by lfant.\n";
	string ind = GetIndent();
	if(ind.size() > 0) ind.erase(ind.begin());

	if(parent)
	{
		stream << ind << type;
		if(!type.empty())
			stream << " ";
		if(!name.empty())
			stream << name;
		stream << "\n"+ind+"{\n";
	}

	for(auto& i : values)
	{
		stream << ind+"\t" << i.first << " = " << i.second.str << "\n";
	}

	for(auto& child : children)
	{
		stream << "\n";
		child->SaveStream(stream);
	}

	if(parent)
		stream << ind << "}\n";
}

Properties* Properties::GetFirstChild()
{
	if(children.size() > 0)
	{
		return children[0];
	}
	else
	{
		return nullptr;
	}
}

void Properties::SaveFile(string path)
{
	ofstream out {path};
	SaveStream(out);
	out.close();
}

Properties* Properties::GetChild(string type, string name)
{
	to_lower(type);
	for(auto& child : children)
	{
		if(child->type == type && (name.empty() || child->name == name))
		{
//			GetGame()->Log("Properties::GetChild: Got child namespace '"+child->type+"'.");
			return child;
		}
	}
	return nullptr;
}

Properties* Properties::GetChild(uint idx)
{
	if(children.size() > idx)
	{
		return children[idx];
	}
	else
	{
		return nullptr;
	}
}

Properties* Properties::AddChild(Properties* prop)
{
	if(prop->parent)
	{
		for(uint i = 0; i < prop->parent->children.size(); ++i)
		{
			if(prop->parent->children[i] == prop)
			{
				prop->parent->children.erase(prop->parent->children.begin()+i);
			}
		}
	}
	prop->parent = this;
	children.push_back(prop);
	return prop;
}

Properties* Properties::AddChild(string name)
{
	return new Properties(this, name);
}

bool Properties::IsType(string type)
{
	to_lower(type);
	return this->type == type;
}

bool Properties::IsNamed(string name)
{
	return this->name == name;
}

void Properties::Rename(string name)
{
	this->name = name;
}

void Properties::SetType(string type)
{
	to_lower(type);
	this->type = type;
}


void Properties::Clear()
{
	type.clear();
	name.clear();

	values.clear();
	children.clear();
}

void Properties::SkipSpace(istream &stream)
{
	signed char c = stream.get();
	while (isspace(c) && c != EOF)
	{
		c = stream.get();
	}

	// If we are not at the end of the file, then since we found a
	// non-whitespace character, we put the cursor back in front of it.
	if (c != EOF)
	{
		stream.seekg(-1, ios_base::cur);
	}
}

/// @todo Switch to new string instead of erasing?
string Properties::TrimSpace(const string& str, bool onlyIndent)
{
	std::size_t firstLetter = str.find_first_not_of(" \t\n");
	std::size_t lastLetter = str.find_last_not_of(" \t\n");

	if(firstLetter == string::npos)
	{
		return "";
	}
	else if(onlyIndent)
	{
		return str.substr(firstLetter);
	}
	else
	{
		return str.substr(firstLetter, lastLetter-firstLetter+1);
	}
}

string Properties::Expand(string value)
{
	return value;
}

string Properties::GetIndent()
{
	if(parent)
	{
		return parent->GetIndent()+"\t";
	}
	else
	{
		return "";
	}
}

Properties* Properties::GetTopParent()
{
	Properties* prop = this;
	while(prop->parent) prop = prop->parent;
	return prop;
}

string Properties::GetString(string name)
{
	return values[name];
}

void Properties::SetString(string name, Value value)
{
	values[name] = value;
}

Properties* Properties::Iterator::operator*()
{
	return prop->GetChild(pos);
}

bool Properties::Iterator::operator!=(const Properties::Iterator& other) const
{
	return pos != other.pos;
}

const Properties::Iterator& Properties::Iterator::operator++()
{
	++pos;
	return *this;
}


void Properties::ScriptBind()
{
	Script::ClassBase<Properties, Sqrat::Class<Properties, Sqrat::NoCopy<Properties>>> inst;
	inst.Func("GetString", (string (Properties::*)(string))&Properties::Get<string>);
	inst.Func("GetInt", (int (Properties::*)(string))&Properties::Get<int>);
	inst.Func("GetFloat", (float (Properties::*)(string))&Properties::Get<float>);
	inst.Func("GetVec3", (vec3 (Properties::*)(string))&Properties::Get<vec3>);
	inst.Func("GetVec2", (vec2 (Properties::*)(string))&Properties::Get<vec2>);
	inst.Bind("Properties");
}

}
